/**
 * Vulnerability Types in C/C++ - Exploit Development
 * 
 * This program demonstrates various types of vulnerabilities in C/C++
 * that can be exploited. For educational purposes only.
 * 
 * WARNING: This code intentionally contains security vulnerabilities
 * to demonstrate exploit concepts. DO NOT use in production.
 */

#include <iostream>
#include <cstring>
#include <string>
#include <vector>
#include <unordered_map>
#include <thread>
#include <mutex>
#include <fstream>

// Forward declarations
void demonstrate_buffer_overflow();
void demonstrate_format_string();
void demonstrate_integer_overflow();
void demonstrate_use_after_free();
void demonstrate_double_free();
void demonstrate_null_pointer_dereference();
void demonstrate_race_condition();
void demonstrate_command_injection();
void demonstrate_path_traversal();
void demonstrate_uninitialized_memory();

/**
 * Main function to demonstrate various vulnerability types
 */
int main() {
    std::cout << "=== Vulnerability Types in C/C++ ===\n";
    std::cout << "WARNING: This code intentionally contains security vulnerabilities\n";
    std::cout << "to demonstrate exploit concepts. DO NOT use in production.\n\n";
    
    int choice = 0;
    
    do {
        std::cout << "\nSelect a vulnerability type to demonstrate:\n";
        std::cout << "1. Buffer Overflow\n";
        std::cout << "2. Format String Vulnerability\n";
        std::cout << "3. Integer Overflow/Underflow\n";
        std::cout << "4. Use-After-Free\n";
        std::cout << "5. Double Free\n";
        std::cout << "6. Null Pointer Dereference\n";
        std::cout << "7. Race Condition\n";
        std::cout << "8. Command Injection\n";
        std::cout << "9. Path Traversal\n";
        std::cout << "10. Uninitialized Memory\n";
        std::cout << "0. Exit\n";
        std::cout << "Enter your choice: ";
        
        // For demonstration, we'll use a fixed choice
        // In a real program, you would get input from the user
        choice = 1;  // Change this to demonstrate different vulnerabilities
        std::cout << choice << std::endl;
        
        switch (choice) {
            case 1:
                demonstrate_buffer_overflow();
                break;
            case 2:
                demonstrate_format_string();
                break;
            case 3:
                demonstrate_integer_overflow();
                break;
            case 4:
                demonstrate_use_after_free();
                break;
            case 5:
                demonstrate_double_free();
                break;
            case 6:
                demonstrate_null_pointer_dereference();
                break;
            case 7:
                demonstrate_race_condition();
                break;
            case 8:
                demonstrate_command_injection();
                break;
            case 9:
                demonstrate_path_traversal();
                break;
            case 10:
                demonstrate_uninitialized_memory();
                break;
            case 0:
                std::cout << "Exiting...\n";
                break;
            default:
                std::cout << "Invalid choice. Please try again.\n";
        }
        
        // For demonstration, we'll exit after one vulnerability
        choice = 0;
        
    } while (choice != 0);
    
    return 0;
}

/**
 * Demonstrate buffer overflow vulnerability
 */
void demonstrate_buffer_overflow() {
    std::cout << "\n=== Buffer Overflow Vulnerability ===\n";
    
    // Stack-based buffer overflow
    std::cout << "1. Stack-based buffer overflow:\n";
    
    char buffer[16];  // Small buffer on the stack
    char large_input[] = "This is a very long input string that will overflow the buffer and potentially overwrite adjacent memory";
    
    std::cout << "Buffer size: 16 bytes\n";
    std::cout << "Input size: " << strlen(large_input) + 1 << " bytes\n";
    
    // Vulnerable code - no bounds checking
    std::cout << "Copying input to buffer without bounds checking...\n";
    // strcpy(buffer, large_input);  // Commented out to prevent actual crash
    
    std::cout << "If executed, this would likely cause a buffer overflow.\n";
    std::cout << "Potential consequences:\n";
    std::cout << "- Overwriting adjacent variables on the stack\n";
    std::cout << "- Overwriting the return address to hijack control flow\n";
    std::cout << "- Program crash or arbitrary code execution\n";
    
    // Heap-based buffer overflow
    std::cout << "\n2. Heap-based buffer overflow:\n";
    
    char* heap_buffer = new char[16];  // Small buffer on the heap
    
    std::cout << "Heap buffer size: 16 bytes\n";
    
    // Vulnerable code - no bounds checking
    std::cout << "Copying input to heap buffer without bounds checking...\n";
    // strcpy(heap_buffer, large_input);  // Commented out to prevent actual crash
    
    std::cout << "If executed, this would likely cause a heap buffer overflow.\n";
    std::cout << "Potential consequences:\n";
    std::cout << "- Corrupting heap metadata\n";
    std::cout << "- Overwriting adjacent heap allocations\n";
    std::cout << "- Program crash or arbitrary code execution\n";
    
    // Clean up
    delete[] heap_buffer;
    
    // Safe alternatives
    std::cout << "\nSafe alternatives:\n";
    std::cout << "1. Use strncpy() with proper bounds checking:\n";
    std::cout << "   strncpy(buffer, input, sizeof(buffer) - 1);\n";
    std::cout << "   buffer[sizeof(buffer) - 1] = '\\0';  // Ensure null termination\n";
    
    std::cout << "2. Use std::string instead of char arrays:\n";
    std::cout << "   std::string safe_string = input;  // Automatically manages memory\n";
    
    std::cout << "3. Use std::vector<char> for dynamic buffers:\n";
    std::cout << "   std::vector<char> safe_buffer(input, input + strlen(input) + 1);\n";
    
    std::cout << "4. Use secure functions like strlcpy() where available\n";
    
    std::cout << "\nMitigation techniques:\n";
    std::cout << "- Stack canaries/cookies to detect stack corruption\n";
    std::cout << "- Address Space Layout Randomization (ASLR)\n";
    std::cout << "- Data Execution Prevention (DEP/NX)\n";
    std::cout << "- Compiler options: -fstack-protector, -D_FORTIFY_SOURCE=2\n";
}

/**
 * Demonstrate format string vulnerability
 */
void demonstrate_format_string() {
    std::cout << "\n=== Format String Vulnerability ===\n";
    
    // User-controlled format string
    const char* user_input = "%x %x %x %s";  // Malicious format string
    
    std::cout << "User input: \"" << user_input << "\"\n";
    
    // Vulnerable code - passing user input as format string
    std::cout << "Vulnerable printf call (commented out for safety):\n";
    std::cout << "printf(user_input);\n";
    
    // printf(user_input);  // Commented out to prevent actual crash
    
    std::cout << "If executed, this would treat the input as a format string.\n";
    std::cout << "Potential consequences:\n";
    std::cout << "- Reading arbitrary memory locations\n";
    std::cout << "- Information disclosure (leaking sensitive data)\n";
    std::cout << "- Writing to arbitrary memory locations\n";
    std::cout << "- Program crash or arbitrary code execution\n";
    
    // Safe alternatives
    std::cout << "\nSafe alternatives:\n";
    std::cout << "1. Always use format specifiers explicitly:\n";
    std::cout << "   printf(\"%s\", user_input);  // User input as argument, not format string\n";
    
    std::cout << "2. Use C++ streams instead of printf:\n";
    std::cout << "   std::cout << user_input;  // No format string interpretation\n";
    
    std::cout << "\nMitigation techniques:\n";
    std::cout << "- Compiler options: -Wformat -Wformat-security\n";
    std::cout << "- Use format string hardening functions where available\n";
    std::cout << "- Static analysis tools to detect format string vulnerabilities\n";
}

/**
 * Demonstrate integer overflow/underflow vulnerability
 */
void demonstrate_integer_overflow() {
    std::cout << "\n=== Integer Overflow/Underflow Vulnerability ===\n";
    
    // Integer overflow
    std::cout << "1. Integer overflow:\n";
    
    int max_int = INT_MAX;
    std::cout << "Maximum int value: " << max_int << "\n";
    
    // Vulnerable code - integer overflow
    std::cout << "Adding 1 to maximum int value...\n";
    int result_overflow = max_int + 1;
    
    std::cout << "Result: " << result_overflow << "\n";
    std::cout << "This caused an integer overflow, wrapping around to a negative number.\n";
    
    // Integer underflow
    std::cout << "\n2. Integer underflow:\n";
    
    int min_int = INT_MIN;
    std::cout << "Minimum int value: " << min_int << "\n";
    
    // Vulnerable code - integer underflow
    std::cout << "Subtracting 1 from minimum int value...\n";
    int result_underflow = min_int - 1;
    
    std::cout << "Result: " << result_underflow << "\n";
    std::cout << "This caused an integer underflow, wrapping around to a positive number.\n";
    
    // Security implications
    std::cout << "\n3. Security implications:\n";
    
    // Allocation size calculation
    std::cout << "Example: Calculating buffer size for allocation\n";
    
    int num_elements = 1000000;
    int element_size = 1000;
    
    // Vulnerable code - integer overflow in calculation
    std::cout << "Calculating total size: num_elements * element_size\n";
    int total_size = num_elements * element_size;  // Will overflow
    
    std::cout << "Requested size: " << num_elements << " * " << element_size << " = " << total_size << " bytes\n";
    std::cout << "Due to integer overflow, the calculated size is much smaller than intended.\n";
    std::cout << "This could lead to a buffer overflow when using the calculated size.\n";
    
    // Safe alternatives
    std::cout << "\nSafe alternatives:\n";
    std::cout << "1. Use larger integer types for calculations:\n";
    std::cout << "   size_t total = static_cast<size_t>(num_elements) * element_size;\n";
    
    std::cout << "2. Check for overflow before performing operations:\n";
    std::cout << "   if (num_elements > INT_MAX / element_size) { /* Handle error */ }\n";
    
    std::cout << "3. Use safe integer libraries or built-in checked arithmetic:\n";
    std::cout << "   SafeInt<int> safe_total = num_elements * element_size;  // Will throw on overflow\n";
    
    std::cout << "\nMitigation techniques:\n";
    std::cout << "- Use appropriate integer types for the expected range of values\n";
    std::cout << "- Validate input values before performing calculations\n";
    std::cout << "- Use compiler options for overflow checking: -ftrapv, -fsanitize=integer\n";
    std::cout << "- Consider using fixed-width integer types (uint32_t, int64_t, etc.)\n";
}

/**
 * Demonstrate use-after-free vulnerability
 */
void demonstrate_use_after_free() {
    std::cout << "\n=== Use-After-Free Vulnerability ===\n";
    
    // Allocate memory
    std::cout << "Allocating memory for a string...\n";
    char* buffer = new char[100];
    strcpy(buffer, "Sensitive data");
    
    std::cout << "Buffer contains: " << buffer << "\n";
    
    // Free the memory
    std::cout << "Freeing the memory...\n";
    delete[] buffer;
    
    // Vulnerable code - using memory after it's been freed
    std::cout << "Attempting to use the memory after it's been freed (commented out for safety):\n";
    std::cout << "printf(\"Buffer after free: %s\\n\", buffer);  // Use-after-free vulnerability\n";
    
    // printf("Buffer after free: %s\n", buffer);  // Commented out to prevent undefined behavior
    
    std::cout << "If executed, this would access memory that has been freed.\n";
    std::cout << "Potential consequences:\n";
    std::cout << "- Reading garbage or sensitive data from reallocated memory\n";
    std::cout << "- Program crash if memory has been reallocated or protected\n";
    std::cout << "- Arbitrary code execution if an attacker can control the reallocated memory\n";
    
    // Demonstrate reallocation
    std::cout << "\nDemonstrating memory reallocation after free:\n";
    
    // Allocate new memory (might reuse the freed memory)
    char* new_buffer = new char[100];
    strcpy(new_buffer, "New data that overwrites the freed memory");
    
    std::cout << "New buffer contains: " << new_buffer << "\n";
    
    // If we were to use the original buffer now, we might see the new data
    std::cout << "If we used the original buffer now, we might see the new data\n";
    std::cout << "or experience undefined behavior.\n";
    
    // Clean up
    delete[] new_buffer;
    
    // Safe alternatives
    std::cout << "\nSafe alternatives:\n";
    std::cout << "1. Set pointers to NULL after freeing:\n";
    std::cout << "   delete[] buffer;\n";
    std::cout << "   buffer = NULL;  // Prevents use-after-free\n";
    
    std::cout << "2. Use smart pointers to manage memory automatically:\n";
    std::cout << "   std::unique_ptr<char[]> safe_buffer(new char[100]);\n";
    std::cout << "   // Memory automatically freed when safe_buffer goes out of scope\n";
    
    std::cout << "3. Use containers like std::string or std::vector instead of raw arrays:\n";
    std::cout << "   std::string safe_string = \"Sensitive data\";\n";
    
    std::cout << "\nMitigation techniques:\n";
    std::cout << "- Use memory debugging tools like AddressSanitizer or Valgrind\n";
    std::cout << "- Implement secure coding practices and code reviews\n";
    std::cout << "- Consider using garbage collection or reference counting\n";
}

/**
 * Demonstrate double free vulnerability
 */
void demonstrate_double_free() {
    std::cout << "\n=== Double Free Vulnerability ===\n";
    
    // Allocate memory
    std::cout << "Allocating memory...\n";
    int* ptr = new int(42);
    
    std::cout << "Pointer value: " << *ptr << "\n";
    
    // Free the memory
    std::cout << "Freeing the memory...\n";
    delete ptr;
    
    // Vulnerable code - freeing the memory again
    std::cout << "Attempting to free the memory again (commented out for safety):\n";
    std::cout << "delete ptr;  // Double free vulnerability\n";
    
    // delete ptr;  // Commented out to prevent undefined behavior
    
    std::cout << "If executed, this would free already freed memory.\n";
    std::cout << "Potential consequences:\n";
    std::cout << "- Corrupting memory allocator metadata\n";
    std::cout << "- Program crash\n";
    std::cout << "- Arbitrary code execution if an attacker can exploit the corruption\n";
    
    // Safe alternatives
    std::cout << "\nSafe alternatives:\n";
    std::cout << "1. Set pointers to NULL after freeing:\n";
    std::cout << "   delete ptr;\n";
    std::cout << "   ptr = NULL;  // Prevents double free\n";
    
    std::cout << "2. Use smart pointers to manage memory automatically:\n";
    std::cout << "   std::unique_ptr<int> safe_ptr(new int(42));\n";
    std::cout << "   // Memory automatically freed once when safe_ptr goes out of scope\n";
    
    std::cout << "\nMitigation techniques:\n";
    std::cout << "- Use memory debugging tools like AddressSanitizer or Valgrind\n";
    std::cout << "- Implement secure coding practices and code reviews\n";
    std::cout << "- Consider using garbage collection or reference counting\n";
}

/**
 * Demonstrate null pointer dereference vulnerability
 */
void demonstrate_null_pointer_dereference() {
    std::cout << "\n=== Null Pointer Dereference Vulnerability ===\n";
    
    // Create a null pointer
    std::cout << "Creating a null pointer...\n";
    int* ptr = NULL;
    
    // Vulnerable code - dereferencing a null pointer
    std::cout << "Attempting to dereference a null pointer (commented out for safety):\n";
    std::cout << "int value = *ptr;  // Null pointer dereference\n";
    
    // int value = *ptr;  // Commented out to prevent program crash
    
    std::cout << "If executed, this would attempt to access memory at address 0.\n";
    std::cout << "Potential consequences:\n";
    std::cout << "- Program crash (segmentation fault)\n";
    std::cout << "- In some environments, potential security implications\n";
    
    // Function call with null pointer
    std::cout << "\nFunction call with null pointer:\n";
    
    // Define a function that doesn't check for null
    auto process_data = [](int* data) {
        // Vulnerable code - no null check before dereferencing
        std::cout << "Function attempting to use the pointer without checking (commented out):\n";
        std::cout << "return *data * 2;  // Null pointer dereference if data is NULL\n";
        
        // return *data * 2;  // Commented out to prevent program crash
        
        // Safe version with null check
        if (data != NULL) {
            return *data * 2;
        } else {
            std::cout << "Null pointer detected, handling safely\n";
            return 0;
        }
    };
    
    // Call the function with a null pointer
    int result = process_data(ptr);
    std::cout << "Function result: " << result << "\n";
    
    // Safe alternatives
    std::cout << "\nSafe alternatives:\n";
    std::cout << "1. Always check pointers before dereferencing:\n";
    std::cout << "   if (ptr != NULL) {\n";
    std::cout << "       int value = *ptr;  // Safe dereference\n";
    std::cout << "   }\n";
    
    std::cout << "2. Use references instead of pointers when possible:\n";
    std::cout << "   void process(int& value) {  // Reference cannot be null\n";
    std::cout << "       value *= 2;  // Safe operation\n";
    std::cout << "   }\n";
    
    std::cout << "3. Use smart pointers with proper checking:\n";
    std::cout << "   std::unique_ptr<int> safe_ptr = std::make_unique<int>(42);\n";
    std::cout << "   if (safe_ptr) {  // Check if the pointer is valid\n";
    std::cout << "       int value = *safe_ptr;  // Safe dereference\n";
    std::cout << "   }\n";
    
    std::cout << "\nMitigation techniques:\n";
    std::cout << "- Use static analysis tools to detect potential null dereferences\n";
    std::cout << "- Implement defensive programming with null checks\n";
    std::cout << "- Consider using the Null Object pattern where appropriate\n";
}

/**
 * Demonstrate race condition vulnerability
 */
void demonstrate_race_condition() {
    std::cout << "\n=== Race Condition Vulnerability ===\n";
    
    // Shared resource
    int balance = 1000;  // Initial account balance
    
    std::cout << "Initial account balance: $" << balance << "\n";
    
    // Function to withdraw money (vulnerable to race conditions)
    auto withdraw = [&balance](int amount, const std::string& user) {
        // Check if sufficient funds are available
        if (balance >= amount) {
            // Simulate some processing time
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
            
            // Withdraw the amount
            balance -= amount;
            
            std::cout << user << " withdrew $" << amount << ", new balance: $" << balance << "\n";
            return true;
        } else {
            std::cout << user << " failed to withdraw $" << amount << ", insufficient funds\n";
            return false;
        }
    };
    
    // Demonstrate race condition with concurrent withdrawals
    std::cout << "\nDemonstrating race condition with concurrent withdrawals:\n";
    
    // Create threads for concurrent withdrawals
    std::thread t1(withdraw, 800, "User1");
    std::thread t2(withdraw, 800, "User2");
    
    // Wait for both threads to complete
    t1.join();
    t2.join();
    
    std::cout << "Final balance: $" << balance << "\n";
    std::cout << "Due to the race condition, both withdrawals might succeed\n";
    std::cout << "even though there are insufficient funds for both.\n";
    
    // Reset balance for the next demonstration
    balance = 1000;
    
    // Safe version with mutex protection
    std::cout << "\nDemonstrating thread-safe version with mutex protection:\n";
    
    std::mutex balance_mutex;
    
    // Thread-safe withdraw function
    auto safe_withdraw = [&balance, &balance_mutex](int amount, const std::string& user) {
        // Lock the mutex to ensure exclusive access
        std::lock_guard<std::mutex> lock(balance_mutex);
        
        // Check if sufficient funds are available
        if (balance >= amount) {
            // Simulate some processing time
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
            
            // Withdraw the amount
            balance -= amount;
            
            std::cout << user << " withdrew $" << amount << ", new balance: $" << balance << "\n";
            return true;
        } else {
            std::cout << user << " failed to withdraw $" << amount << ", insufficient funds\n";
            return false;
        }
    };
    
    // Create threads for concurrent withdrawals (thread-safe)
    std::thread t3(safe_withdraw, 800, "User1");
    std::thread t4(safe_withdraw, 800, "User2");
    
    // Wait for both threads to complete
    t3.join();
    t4.join();
    
    std::cout << "Final balance: $" << balance << "\n";
    std::cout << "With mutex protection, only one withdrawal succeeds\n";
    std::cout << "when there are insufficient funds for both.\n";
    
    // Safe alternatives
    std::cout << "\nSafe alternatives for preventing race conditions:\n";
    std::cout << "1. Use mutex locks to protect shared resources:\n";
    std::cout << "   std::mutex mutex;\n";
    std::cout << "   std::lock_guard<std::mutex> lock(mutex);  // RAII lock\n";
    
    std::cout << "2. Use atomic operations for simple data types:\n";
    std::cout << "   std::atomic<int> atomic_balance(1000);\n";
    std::cout << "   atomic_balance.fetch_sub(amount);  // Atomic subtraction\n";
    
    std::cout << "3. Use higher-level synchronization primitives:\n";
    std::cout << "   - std::shared_mutex for reader-writer scenarios\n";
    std::cout << "   - std::condition_variable for signaling between threads\n";
    
    std::cout << "\nMitigation techniques:\n";
    std::cout << "- Identify shared resources and protect them with appropriate locks\n";
    std::cout << "- Minimize the scope of locks to prevent deadlocks\n";
    std::cout << "- Use thread-safe data structures and algorithms\n";
    std::cout << "- Consider using thread-local storage for thread-specific data\n";
}

/**
 * Demonstrate command injection vulnerability
 */
void demonstrate_command_injection() {
    std::cout << "\n=== Command Injection Vulnerability ===\n";
    
    // Function to ping a host (vulnerable to command injection)
    auto ping_host = [](const std::string& host) {
        std::cout << "Pinging host: " << host << "\n";
        
        // Vulnerable code - directly using user input in a command
        std::string command = "ping -c 1 " + host;
        
        std::cout << "Executing command: " << command << "\n";
        
        // In a real program, this would execute the command
        // system(command.c_str());  // Commented out for safety
        
        std::cout << "If executed, this would run the command with the host parameter.\n";
    };
    
    // Normal usage
    std::cout << "Normal usage:\n";
    ping_host("example.com");
    
    // Malicious input with command injection
    std::cout << "\nMalicious input with command injection:\n";
    ping_host("example.com; rm -rf /important_files");  // Command injection
    
    std::cout << "The malicious input contains a command separator (;)\n";
    std::cout << "which would cause the 'rm' command to execute after the ping.\n";
    
    // Safe alternatives
    std::cout << "\nSafe alternatives:\n";
    std::cout << "1. Validate and sanitize user input:\n";
    std::cout << "   - Allow only alphanumeric characters, dots, and hyphens\n";
    std::cout << "   - Reject input containing shell metacharacters (;, |, &, etc.)\n";
    
    std::cout << "2. Use library functions instead of shell commands:\n";
    std::cout << "   - Use socket APIs for network operations\n";
    std::cout << "   - Use file APIs for file operations\n";
    
    std::cout << "3. If shell commands are necessary, use safer alternatives:\n";
    std::cout << "   - execve() family of functions with explicit arguments\n";
    std::cout << "   - popen() with careful input validation\n";
    
    std::cout << "\nExample of input validation:\n";
    auto is_valid_hostname = [](const std::string& host) {
        // Check if hostname contains only allowed characters
        for (char c : host) {
            if (!isalnum(c) && c != '.' && c != '-') {
                return false;
            }
        }
        return true;
    };
    
    std::cout << "Validating 'example.com': " << (is_valid_hostname("example.com") ? "Valid" : "Invalid") << "\n";
    std::cout << "Validating 'example.com; rm -rf /': " << (is_valid_hostname("example.com; rm -rf /") ? "Valid" : "Invalid") << "\n";
    
    std::cout << "\nMitigation techniques:\n";
    std::cout << "- Implement strict input validation\n";
    std::cout << "- Use parameterized APIs instead of string concatenation\n";
    std::cout << "- Run with minimal privileges\n";
    std::cout << "- Consider using sandboxing or containerization\n";
}

/**
 * Demonstrate path traversal vulnerability
 */
void demonstrate_path_traversal() {
    std::cout << "\n=== Path Traversal Vulnerability ===\n";
    
    // Function to read a file (vulnerable to path traversal)
    auto read_file = [](const std::string& filename) {
        std::cout << "Reading file: " << filename << "\n";
        
        // Vulnerable code - directly using user input in a file path
        std::string filepath = "data/" + filename;
        
        std::cout << "Opening file: " << filepath << "\n";
        
        // In a real program, this would open and read the file
        // std::ifstream file(filepath);
        // if (file) {
        //     std::string content((std::istreambuf_iterator<char>(file)),
        //                          std::istreambuf_iterator<char>());
        //     std::cout << "File content: " << content << "\n";
        // } else {
        //     std::cout << "Failed to open file\n";
        // }
        
        std::cout << "If executed, this would attempt to read the specified file.\n";
    };
    
    // Normal usage
    std::cout << "Normal usage:\n";
    read_file("user_data.txt");
    
    // Malicious input with path traversal
    std::cout << "\nMalicious input with path traversal:\n";
    read_file("../../../etc/passwd");  // Path traversal
    
    std::cout << "The malicious input contains directory traversal sequences (../)\n";
    std::cout << "which could allow accessing files outside the intended directory.\n";
    
    // Safe alternatives
    std::cout << "\nSafe alternatives:\n";
    std::cout << "1. Validate and sanitize file paths:\n";
    std::cout << "   - Reject paths containing '../', '..\\', or absolute paths\n";
    std::cout << "   - Canonicalize paths and verify they're within allowed directories\n";
    
    std::cout << "2. Use a whitelist of allowed files:\n";
    std::cout << "   - Only allow access to specific, pre-approved files\n";
    std::cout << "   - Reject any file not in the whitelist\n";
    
    std::cout << "3. Use secure APIs for file access:\n";
    std::cout << "   - Some libraries provide secure file access functions\n";
    std::cout << "   - Consider using virtual file systems or sandboxed environments\n";
    
    std::cout << "\nExample of path validation:\n";
    auto is_safe_path = [](const std::string& path) {
        // Check if path contains directory traversal sequences or is absolute
        return path.find("../") == std::string::npos &&
               path.find("..\\") == std::string::npos &&
               path.find(':') == std::string::npos &&
               path[0] != '/';
    };
    
    std::cout << "Validating 'user_data.txt': " << (is_safe_path("user_data.txt") ? "Safe" : "Unsafe") << "\n";
    std::cout << "Validating '../../../etc/passwd': " << (is_safe_path("../../../etc/passwd") ? "Safe" : "Unsafe") << "\n";
    
    std::cout << "\nMitigation techniques:\n";
    std::cout << "- Implement strict path validation\n";
    std::cout << "- Use library functions to canonicalize and validate paths\n";
    std::cout << "- Run with minimal file system privileges\n";
    std::cout << "- Consider using chroot jails or containerization\n";
}

/**
 * Demonstrate uninitialized memory vulnerability
 */
void demonstrate_uninitialized_memory() {
    std::cout << "\n=== Uninitialized Memory Vulnerability ===\n";
    
    // Uninitialized stack variable
    std::cout << "1. Uninitialized stack variable:\n";
    
    int uninitialized_var;  // Uninitialized variable
    
    std::cout << "Declared an uninitialized variable\n";
    
    // Vulnerable code - using uninitialized variable
    std::cout << "Attempting to use the uninitialized variable (commented out for safety):\n";
    std::cout << "printf(\"Value: %d\\n\", uninitialized_var);  // Undefined behavior\n";
    
    // printf("Value: %d\n", uninitialized_var);  // Commented out to prevent undefined behavior
    
    std::cout << "If executed, this would print whatever value happens to be in that memory location.\n";
    
    // Uninitialized heap memory
    std::cout << "\n2. Uninitialized heap memory:\n";
    
    // Allocate memory without initialization
    char* buffer = new char[10];  // Uninitialized buffer
    
    std::cout << "Allocated a buffer without initialization\n";
    
    // Vulnerable code - using uninitialized buffer
    std::cout << "Attempting to use the uninitialized buffer (commented out for safety):\n";
    std::cout << "printf(\"Buffer: %s\\n\", buffer);  // Undefined behavior\n";
    
    // printf("Buffer: %s\n", buffer);  // Commented out to prevent undefined behavior
    
    std::cout << "If executed, this could print whatever data was previously in that memory location,\n";
    std::cout << "potentially leaking sensitive information from previous allocations.\n";
    
    // Clean up
    delete[] buffer;
    
    // Safe alternatives
    std::cout << "\nSafe alternatives:\n";
    std::cout << "1. Always initialize variables when declared:\n";
    std::cout << "   int initialized_var = 0;  // Explicitly initialized\n";
    
    std::cout << "2. Use initialization syntax for arrays and structures:\n";
    std::cout << "   int array[10] = {0};  // Initialize all elements to 0\n";
    std::cout << "   struct Data data = {0};  // Initialize all fields to 0\n";
    
    std::cout << "3. Use calloc() instead of malloc() for zero-initialized memory:\n";
    std::cout << "   int* safe_buffer = (int*)calloc(10, sizeof(int));  // Zero-initialized\n";
    
    std::cout << "4. Use secure memory allocation functions that initialize memory:\n";
    std::cout << "   char* secure_buffer = new char[10]();  // Zero-initialized in C++\n";
    
    std::cout << "\nMitigation techniques:\n";
    std::cout << "- Use compiler warnings for uninitialized variables: -Wuninitialized\n";
    std::cout << "- Use static analysis tools to detect uninitialized memory usage\n";
    std::cout << "- Use memory debugging tools like Valgrind or AddressSanitizer\n";
    std::cout << "- Consider using languages or libraries with automatic initialization\n";
}

